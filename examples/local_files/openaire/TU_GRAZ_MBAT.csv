"doi","id","subject","title","authors","year","publisher","resulttype","language","journal","url","paper_abstract","project_id","accessright","x","y","area_uri","cluster_labels","area","citation_count","cited_by_tweeters_count","readers.mendeley","readers","file_hash"
"","dedup_wf_001::4b458be50642ab1b167ea1cd2d668318","Termination","To Infinity... and Beyond!","Urban, Caterina","2014-07-17","HAL CCSD","publication","","","https://hal.inria.fr/hal-01105216/document","International audience; The traditional method for proving program termination consists in inferring a ranking function. In many cases (i.e. programs with unbounded non-determinism), a single ranking function over natural numbers is not sufficient. Hence, we propose a new abstract domain to automatically infer ranking functions over ordinals. We extend an existing domain for piecewise-defined natural-valued ranking functions to polynomials in ω, where the polynomial coefficients are natural-valued functions of the program variables. The abstract domain is parametric in the choice of the state partitioning inducing the piecewise-definition and the type of functions used as polynomial coefficients. To our knowledge this is the first abstract domain able to reason about ordinals. Handling ordinals leads to a powerful approach for proving termination of imperative programs, which in particular allows us to take a first step in the direction of proving termination under fairness constraints and proving liveness properties of (sequential and) concurrent programs.","269335","Open Access","-0.1261","-0.5822","9","Termination","Termination",NA,NA,NA,"",""
"","od________18::e6c7de19cf4c3b27294331e9f6624ee5","Computer Science - Data Structures and Algorithms","An n log n Alogrithm for Deterministic Kripke Structure Minimization","Meinke, Karl","2012-05-26","","publication","","","","We introduce an algorithm for the minimization of deterministic Kripke structures with O(kn log2 n) time complexity. We prove the correctness and complexity properties of this algorithm.","269335","Open Access","0.6812","0.2431","12","Computer science - data structures and algorithms","Computer science - data structures and algorithms",NA,NA,NA,"",""
"10.1007/978-3-319-09099-3_16","dedup_wf_001::01700954e920159bd4ecb8f73acb7d57","[INFO.INFO-LO] Computer Science [cs]/Logic in Computer Science [cs.LO]","How Test Generation Helps Software Specification and Deductive Verification in Frama-C","Petiot, Guillaume","2014-07-24","Springer","publication","","","https://hal.inria.fr/hal-01108553/document","International audience; This paper describes an incremental methodology of deductive verification assisted by test generation and illustrates its benefits by a set of frequent verification scenarios. We present StaDy, a new integration of the concolic test generator PathCrawler within the software analysis platform FramaC. This new plugin treats a complete formal specification of a C program during test generation and provides the validation engineer with a helpful feedback at all stages of the specification and verification tasks.","269335","Open Access","-0.5566","-0.2769","2","[info.info-lo] computer science [cs]/logic in computer science [cs.lo]","[info.info-lo] computer science [cs]/logic in computer science [cs.lo]","2",NA,NA,"",""
"10.1007/978-3-319-10936-7_18","dedup_wf_001::26161407404bfce6a3083fde2084f614","[INFO] Computer Science [cs]","An Abstract Domain Combinator for Separately Conjoining Memory Abstractions","Toubhans, Antoine","2014-09-11","Springer","publication","","Static Analysis Symposium (SAS 2014)","https://hal.archives-ouvertes.fr/hal-01095934/document","International audience; The breadth and depth of heap properties that can be inferred by theunion of today’s shape analyses is quite astounding. Yet, achieving scalabilitywhile supporting a wide range of complex data structures in a generic way remainsa long-standing challenge. In this paper, we propose a way to side-stepthis issue by defining a generic abstract domain combinator for combining memoryabstractions on disjoint regions. In essence, our abstract domain constructionis to the separating conjunction in separation logic as the reduced product constructionis to classical, non-separating conjunction. This approach eases the designof the analysis as memory abstract domains can be re-used by applying ourseparating conjunction domain combinator. And more importantly, this combinatorenables an analysis designer to easily create a combined domain that appliescomputationally-expensive abstract domains only where it is required.","269335","Open Access","0.2783","-0.1305","14","[info] computer science [cs]","[info] computer science [cs]","2",NA,NA,"",""
"10.1007/978-3-319-10936-7_19","dedup_wf_001::8c72a67995e6b3116d6324162616a556","Computer Science::Programming Languages","A Decision Tree Abstract Domain for Proving Conditional Termination","Urban, Caterina","2014-09-11","Springer","publication","","","https://hal.inria.fr/hal-01105221/document","International audience; We present a new parameterized abstract domain able to refine existing numerical abstract domains with finite disjunctions. The elements of the abstract domain are decision trees where the decision nodes are labeled with linear constraints, and the leaf nodes belong to a numerical abstract domain. The abstract domain is parametric in the choice between the expressivity and the cost of the linear constraints for the decision nodes (e.g., polyhedral or octagonal constraints), and the choice of the abstract domain for the leaf nodes. We describe an instance of this domain based on piecewise-defined ranking functions for the automatic inference of sufficient preconditions for program termination. We have implemented a static analyzer for proving conditional termination of programs written in (a subset of) C and, using experimental evidence, we show that it performs well on a wide variety of benchmarks, it is competitive with the state of the art and is able to analyze programs that are out of the reach of existing methods.","269335","Open Access","0.0647","-0.5545","6","Computer science::programming languages","Computer science::programming languages","8",NA,NA,"",""
"10.1007/978-3-642-38853-8_10","dedup_wf_001::eaebc4334f72369609fd42c31bd69660","[INFO] Computer Science [cs]","Reducing Re-verification Effort by Requirement-Based Change Management","Oertel, Markus","2013-06-17","Springer","publication","","","https://hal.inria.fr/hal-01466666/document","Part 3: Verification; International audience; Changes in parts of a safety critical system typically require the re-verification of the whole system design. In this paper we present a change management approach that contains the effects of a change within a region of the system. The approach guarantees to maintain the integrity of the system while performing changes. Our approach directly integrates verification and validation activities in the process. Furthermore, the propagation of changes is not based on the interfaces of the components and their interconnections, but exploits the knowledge of the behavior described by the requirements. This approach creates a much more precise set of affected system artifacts. In addition, we propose techniques to analyze the propagation of changes automatically based on formalized requirements and guide the selection of suitable compensation candidates.","269335","Open Access","-0.0542","0.5907","1","[info] computer science [cs]","[info] computer science [cs]","2",NA,NA,"",""
"10.1007/978-3-662-44857-1_6","dedup_wf_001::1be347b7b8c6f478acf5469de1896ac1","ACM : D.: Software/D.2: SOFTWARE ENGINEERING/D.2.5: Testing and Debugging","MPLM -- MaTeLo Product Line Manager","Samih , Hamza","2014-09-15","HAL CCSD","publication","","","https://hal.inria.fr/hal-01025159/document","International audience; The diversity of requirements elicited from different customers leads to the development of many variants. Furthermore, compliance with safety standards as mandated for safety-critical systems requires high test efforts for each variant. Model-based testing aims to reduce test efforts by automatically generating test cases from test models. In this paper, we introduce variability management to usage models, a widely used model-based testing formalism. We present an approach that allows to derive usage model variants from a desired set of features and thus generate test cases for each variant. The approach is integrated in the industrial model-based testing tool chain MaTeLo and exemplified using an industrial case study from the aerospace domain.","269335","Open Access","-0.5541","0.089","8","Acm : d.: software/d.2: software engineering/d.2.5: testing and debugging, Model based testing, Industrial case study","Acm : d.: software/d.2: software engineering/d.2.5: testing and debugging, Model based testing, Industrial case study","2",NA,NA,"",""
"10.1007/978-3-662-44857-1_6","dedup_wf_001::3c451e4468a6ef913492a9717191be37","[INFO] Computer Science [cs]","An Approach to Derive Usage Models Variants for Model-Based Testing","Samih, Hamza","2014-09-23","Springer","publication","","","https://hal.inria.fr/hal-01405276/document","Part 2: Tools and Frameworks; International audience; Testing techniques in industry are not yet adapted for product line engineering (PLE). In particular, Model-based Testing (MBT), a technique that allows to automatically generate test cases from requirements, lacks support for managing variability (differences) among a set of related product. In this paper, we present an approach to equip usage models, a widely used formalism in MBT, with variability capabilities. Formal correspondences are established between a variability model, a set of functional requirements, and a usage model. An algorithm then exploits the traceability links to automatically derive a usage model variant from a desired set of selected features. The approach is integrated into the professional MBT tool MaTeLo and is currently used in industry.","269335","Open Access","-0.4051","0.113","7","[info] computer science [cs]","[info] computer science [cs]","2",NA,NA,"",""
"10.1007/978-3-662-44857-1_6","dedup_wf_001::6f4f2d192048292d8c423a1c75716d60","Requirements","Deriving Usage Model Variants for Model-based Testing: An Industrial Case Study","Samih , Hamza","2014-08-04","IEEE","publication","","","https://hal.inria.fr/hal-01002099/document","International audience; The strong cost pressure of the market and safety issues faced by aerospace industry affect the development. Suppliers are forced to continuously optimize their life-cycle processes to facilitate the development of variants for different customers and shorten time to market. Additionally, industrial safety standards like RTCA/DO-178C require high efforts for testing single products. A suitably organized test process for Product Lines (PL) can meet standards. In this paper, we propose an approach that adopts Model-based Testing (MBT) for PL. Usage models, a widely used MBT formalism that provides automatic test case generation capabilities, are equipped with variability information such that usage model variants can be derived for a given set of features. The approach is integrated in the professional MBT tool MaTeLo. We report on our experience gained from an industrial case study in the aerospace domain.","269335","Open Access","-0.5091","0.1946","8","Acm : d.: software/d.2: software engineering/d.2.5: testing and debugging, Model based testing, Industrial case study","Acm : d.: software/d.2: software engineering/d.2.5: testing and debugging, Model based testing, Industrial case study","2",NA,NA,"",""
"10.1007/978-3-662-45231-8_40","dedup_wf_001::1321a24e8d41da02002d10b725ce2880","[INFO] Computer Science [cs]","Construction of Abstract Domains for Heterogeneous Properties (Position Paper)","Rival, Xavier","2014-10-08","Springer","publication","","6th International Symposium On Leveraging Applications of Formal Methods, Verification and Validation","https://hal.archives-ouvertes.fr/hal-01095977/document","International audience; The aim of static analysis is to infer invariants about programs that are tight enough to establish semantic properties, like the absence of run-time errors. In the last decades, several branches of the static analysis of imperative programs have made significant progress, such as in the inference of numeric invariants or the computation of data structures properties (using pointer abstractions or shape analyzers). Although simultaneous inference of shape-numeric invariants is often needed, this case is especially challenging and less well explored. Notably, simultaneous shape-numeric inference raises complex issues in the design of the static analyzer itself. We study the modular construction of static analyzers, based on combinations of atomic abstract domains to describe several kinds of memory properties and value properties. Static analysis to infer heterogeneous properties. Static analysis by abstract interpreta-tion [4] utilizes an abstraction to over-approximate (non-computable) sets of program states, using computer-representable elements, that stand for logical properties of con-crete program states. As an example, for numerical properties, the interval abstract domain [4] uses constraints of the form n ≤ x and x ≤ p to describe possible values of variable x, where n, p are scalars. To construct a static analyzer capable of inferring sound approximations of program behaviors, one designs an abstract domain, which consists of an abstraction, and abstract operations for sound post-condition operators, join and widening: 1. An abstraction is defined by a set of abstract elements A and a concretization function γ : A → P(C), which maps each abstract property a into the set of concrete elements γ(a) that satisfy it. The set A of abstract elements will be assumed to be defined by a grammar of admissible logical predicates (e.g., for intervals, a(∈ A) ::= a ∧ a | n ≤ x | x ≤ p). 2. A post-condition operator is a function f : A → A which over-approximates a concrete operation f : C → P(C) encountered in programs (as, e.g., a test).","1055066","Open Access","0.2296","-0.3543","13","[info] computer science [cs]","[info] computer science [cs]","0",NA,NA,"",""
"10.1007/978-3-662-46081-8_11","dedup_wf_001::918855f752e645e432185e85ce71b3f4","[INFO.INFO-PF] Computer Science [cs]/Performance [cs.PF]","Proving Guarantee and Recurrence Temporal Properties by Abstract Interpretation","Urban, Caterina","2015-01-12","Springer","publication","","","https://hal.inria.fr/hal-01105238/document","International audience; We present new static analysis methods for proving liveness properties of programs. In particular, with reference to the hierarchy of temporal properties proposed by Manna and Pnueli, we focus on guarantee (i.e., “something good occurs at least once”) and recurrence (i.e., “something good occurs infinitely often”) temporal properties. We generalize the abstract interpretation framework for termination presented by Cousot and Cousot. Specifically, static analyses of guarantee and recurrence temporal properties are systematically derived by abstraction of the program operational trace semantics. These methods automatically infer sufficient preconditions for the temporal properties by reusing existing numerical abstract domains based on piecewise-defined ranking functions. We augment these abstract domains with new abstract operators, including a dual widening. To illustrate the potential of the proposed methods, we have implemented a research prototype static analyzer, for programs written in a C-like syntax, that yielded interesting preliminary results.","269335","Open Access","0.3192","-0.5074","4","[info.info-pf] computer science [cs]/performance [cs.pf]","[info.info-pf] computer science [cs]/performance [cs.pf]","1",NA,NA,"",""
"10.1007/978-3-662-46081-8_16","dedup_wf_001::51b9a1e2f72fa9a2391539203bec73a3","[INFO] Computer Science [cs]","Abstraction of Arrays Based on Non Contiguous Partitions","Liu, Jiangchao","2015-01-12","Springer","publication","","VMCAI 2015","https://hal.archives-ouvertes.fr/hal-01095985/document","International audience; Array partitioning analyses split arrays into contiguous parti-tions to infer properties of cell sets. Such analyses cannot group together non contiguous cells, even when they have similar properties. In this paper, we propose an abstract domain which utilizes semantic properties to split array cells into groups. Cells with similar properties will be packed into groups and abstracted together. Additionally, groups are not necessarily contiguous. This abstract domain allows to infer complex array invariants in a fully automatic way. Experiments on examples from the Minix 1.1 memory management demonstrate its effectiveness.","278673","Open Access","0.5683","-0.2284","10","[info] computer science [cs]","[info] computer science [cs]","4",NA,NA,"",""
"10.1007/s00607-013-0314-4","dedup_wf_001::2b37e5019a79d7830ba15c80a3a26725","EAST-ADL","An architectural approach to the analysis, verification and validation of software intensive embedded systems","Chen, DeJiu","2013-01-01","SPRINGER WIEN","publication","","COMPUTING","","EAST-ADL is a domain specific Architecture Description Language (ADL) for safety-critical and software-intensive embedded systems. The language allows a formalized and traceable description of a wide range of engineering concerns throughout the entire lifecycle of system development. This makes it possible to fully utilize the leverage of state-of-the-art methods and tools for the development of correct-by-construction system functions and components in a seamless and cost efficient way. This paper focuses on the recent advancement of EAST-ADL in supporting an architecture-centric analysis, verification&amp;validation of complex behaviors for the purposes of requirements engineering, application design, and safety engineering. The approach is architecture centric because all behavior descriptions are formalized and connected to a set of standardized design artifacts sitting at multiple levels of abstractions. We present the language design to support this, the theoretical underpinning and tool implementation. To show the capability of EAST-ADL, we also introduce an algorithm and its implementation for transforming the EAST-ADL behavior models to SPIN models for logic model checking. Exploiting mature state-of-the-art technologies from computer science, electronic engineering, and other related domains for a model-based incremental system development, the contribution enables the developers of embedded systems and software to maintain various engineering concerns coherently using EAST-ADL. 
			<p>QC 20130909</p>
			MAENAD (EU FP7, Grant 260057), DFEA2020 (VINNOVA, Grant 2009-00629), and MBAT (ARTEMIS-JU, Grant 269335).","269335","Restricted","0.083","0.3682","11","East-adl","East-adl","12","2","32","",""
"10.22028/d291-25797","dedup_wf_001::58f42eb4d3ee1b34f71fa8372ef00219","[INFO.INFO-ES] Computer Science [cs]/Embedded Systems","Confidence in Timing","Kästner, Daniel","2013-09-24","HAL CCSD","publication","","","https://hal.archives-ouvertes.fr/hal-00848489/document","International audience; All contemporary safety standards require to demonstrate the absence of functional and non-functional safety hazards. In real-time systems this includes demonstrating the absence of critical timing hazards. To meet this veri cation objective it is necessary to show the correctness of the timing behavior with adequate con dence. Adequate con dence means that the evidence provided can be trusted beyond reasonable doubt. There are two main sources of doubt: the logic doubt associated with the validity of the reasoning and the epistemic doubt associated with uncertainty about the underlying assumptions. A fundamental timing property is the per-task worst-case execution (WCET). It is an ingredient for determining all higher-level timing concepts like worst-case response times, and system-wide end-to-end times. This article gives an overview of the challenges in ensuring timeliness of real-time software focusing on the worst-case execution time problem. It describes the principles of abstract interpretation-based WCET analysis and summarizes the con dence argument for applying it in the certi cation process of safety-critical software, addressing both logic and epistemic doubt.","269335","Open Access","0.4067","0.5426","5","[info.info-es] computer science [cs]/embedded systems","[info.info-es] computer science [cs]/embedded systems","",NA,NA,"",""
"10.4204/eptcs.108.2","dedup_wf_001::772f1c7fd15d321f8cd4c0a45303a791","Mathematics","Sequence Diagram Test Case Specification and Virtual Integration Analysis using Timed-Arc Petri Nets","Sieverding, Sven","2013-02-20","Open Publishing Association","publication","","Electronic Proceedings in Theoretical Computer Science","","In this paper, we formally define Test Case Sequence Diagrams (TCSD) as an easy-to-use means to specify test cases for components including timing constraints. These test cases are modeled using the UML2 syntax and can be specified by standard UML-modeling-tools. In a component-based design an early identification of errors can be achieved by a virtual integration of components before the actual system is build. We define such a procedure which integrates the individual test cases of the components according to the interconnections of a given architecture and checks if all specified communication sequences are consistent. Therefore, we formally define the transformation of TCSD into timed-arc Petri nets and a process for the combination of these nets. The applicability of our approach is demonstrated on an avionic use case from the ARP4761 standard.","269335","Open Access","-0.4258","0.4932","3","Mathematics","Mathematics","2","1","4","",""
